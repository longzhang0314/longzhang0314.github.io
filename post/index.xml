<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://longzhang0314.github.io/post/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Sep 2019 15:53:59 +0800</lastBuildDate>
    
	<atom:link href="https://longzhang0314.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>支付系统对于异步通知的处理</title>
      <link>https://longzhang0314.github.io/post/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E5%AF%B9%E4%BA%8E%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 09 Sep 2019 15:53:59 +0800</pubDate>
      
      <guid>https://longzhang0314.github.io/post/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E5%AF%B9%E4%BA%8E%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5%E7%9A%84%E5%A4%84%E7%90%86/</guid>
      <description> 1. 传统做法 调用第三方支付时，支付成功后通过第三方回调来获取最终的支付结果，之后处理支付成功的业务。
2. 如果接不到异步通知怎么办？  一般来说，第三方支付，比如支付宝，新浪支付都会提供相应的交易查询接口，用来对该笔订单的最终结果进行查询。所以，部分企业采用发起交易之后，调用第三方查询来主动查询支付结果，彻底抛弃异步通知机制，保证不会因为网络等原因丢失交易结果。 但是，这种方式也存在一些问题：调用第三支付查询接口时，交易不一定结束，查询到的可能是不确定的结果，比如交易已经在第三方创建成功，但是是否交易成功的结果还没有拿到。针对这种情况，有些企业会采取创建交易后，线程睡眠1秒或2秒进行查询，但这种方式势必会导致用户不必要的等待，降低用户体验，并且，到底等几秒才是最合理的也没有定论。并且，大多数第三方支付的交易查询接口所返回的参数一般都比异步通知的参数要少，比如新浪支付在主动调用交易查询时，无法获得内部交易流失号等，这样会导致获取参数不全的问题。 所以，作者采用以异步通知为主，以定时任务运行交易查询作为异步通知的辅助措施。
3. 具体操作 在异步通知中处理所有的业务逻辑，包括对于必要参数的更新，以及通知订单或其他业务系统做后续的业务操作。使用分布式定时任务调度框架，添加定时查询任务，查询商户系统的流水表，对未拿到异步通知的订单主动去调用第三方查询，拿到最终的结果。作者这里使用的是XXL-JOB分布式任务调度平台。
  4.注意事项  定时任务设置多久一次，查询哪个时间段的订单？ 我们需要以异步通知的结果为准，所以定时任务查询的订单需要查询创建时间在当前时间一段时间之前的订单，仅作为没接到异步通知的保护措施。作者这里设置的是每两分钟一次定时任务，查询当前时间1分钟前到6分钟前的订单，这样可以保证每个待查询订单都有两次机会被定时任务保护，防止查询时仍然是待支付等不确定结果。
 定时任务中也进行业务逻辑，是否会和异步通知中重复，导致业务逻辑执行两次，比如两次发货等？ 可以给异步处理和定时查询的具体逻辑中加锁，作者采用的是mysql更新乐观锁，通过唯一请求号更新具体的交易状态，以update结果是否为1作为条件进行后续逻辑。  </description>
    </item>
    
    <item>
      <title>SpringBoot项目启动时@Mapper注解相关警告</title>
      <link>https://longzhang0314.github.io/post/springboot%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6mapper%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E8%AD%A6%E5%91%8A/</link>
      <pubDate>Mon, 09 Sep 2019 11:26:59 +0800</pubDate>
      
      <guid>https://longzhang0314.github.io/post/springboot%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6mapper%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E8%AD%A6%E5%91%8A/</guid>
      <description>2019-08-27 15:27:27 | WARN | main | org.mybatis.spring.mapper.ClassPathMapperScanner | Skipping MapperFactoryBean with name &#39;compensateTacticsMapper&#39; and &#39;com.basestonedata.finance.mapper.CompensateTacticsMapper&#39; mapperInterface. Bean already defined with the same name! 2019-08-27 15:27:27 | WARN | main | org.mybatis.spring.mapper.ClassPathMapperScanner | Skipping MapperFactoryBean with name &#39;ratesMapper&#39; and &#39;com.basestonedata.finance.mapper.RatesMapper&#39; mapperInterface. Bean already defined with the same name! 2019-08-27 15:27:27 | WARN | main | org.mybatis.spring.mapper.ClassPathMapperScanner | Skipping MapperFactoryBean with name &#39;ratesMouldMapper&#39; and &#39;com.basestonedata.finance.mapper.RatesMouldMapper&#39; mapperInterface. Bean already defined with the same name!</description>
    </item>
    
    <item>
      <title>SpringCloud中不同模块间调用传参问题</title>
      <link>https://longzhang0314.github.io/post/springcloud%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%9D%97%E9%97%B4%E8%B0%83%E7%94%A8%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 09 Sep 2019 11:26:00 +0800</pubDate>
      
      <guid>https://longzhang0314.github.io/post/springcloud%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%9D%97%E9%97%B4%E8%B0%83%E7%94%A8%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</guid>
      <description>不同模块间调用时，通过Feign客户端组件调用其他服务，出现参数传过去后变成null的问题。注意如下：
1. 尽量使用@PostMapping注解，而不是@RequestMapping(value = &amp;ldquo;url&amp;rdquo;,method = RequestMethod.POST)
2. 使用@RequestParam注解时必须要在后面加上参数名
3. Controller层互相调用不要忘记@RequestBody注解</description>
    </item>
    
    <item>
      <title>SpringCloud中其他模块事务能否回滚</title>
      <link>https://longzhang0314.github.io/post/springcloud%E4%B8%AD%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E4%BA%8B%E5%8A%A1%E8%83%BD%E5%90%A6%E5%9B%9E%E6%BB%9A/</link>
      <pubDate>Mon, 09 Sep 2019 11:20:30 +0800</pubDate>
      
      <guid>https://longzhang0314.github.io/post/springcloud%E4%B8%AD%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%E4%BA%8B%E5%8A%A1%E8%83%BD%E5%90%A6%E5%9B%9E%E6%BB%9A/</guid>
      <description>在处理业务逻辑时，遇到异常回滚数据库操作是非常常见的，但是，在SpringCloud的项目中，如果遇到业务抛异常需要回滚调用的其他模块数据库操作，能否有效呢？
1. 使用@Transactional注解在方法上 发现无法回滚，可以回滚本地自己模块的操作，但无法回滚调用的其他模块的数据库操作。 2. 使用手动事务 手动设置回滚点在需要回滚的操作之前，抛异常后手动回滚事务。
//设置回滚点 Object savePoint = TransactionAspectSupport.currentTransactionStatus().createSavepoint(); //数据库代码 /* 代码~~~ */ //手动回滚 TransactionAspectSupport.currentTransactionStatus().rollbackToSavepoint(savePoint);  根据最终结果发现，这种方式也是无效的。 结论 SpringCloud模块中，每个模块对于自己模块的事务管理都是独立的，调用其他模块的服务，想要在本地通过回滚的方式回滚数据库操作是不现实的，所以，需要在代码设计之初就要考虑到这种情况，根据某些确定的条件之后再去做数据库操作，如果确实需要根据结果做回滚操作，可以再将数据update回去或者delete掉。</description>
    </item>
    
    <item>
      <title>Git新建一个分支</title>
      <link>https://longzhang0314.github.io/post/git%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF/</link>
      <pubDate>Wed, 04 Sep 2019 16:12:53 +0800</pubDate>
      
      <guid>https://longzhang0314.github.io/post/git%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF/</guid>
      <description>参考：https://www.cnblogs.com/kaerxifa/p/11045573.html
 进入本地git仓库目录，使用git bash指令，发现只有master分支   使用git branch 分支名来创建分支，创建完成后再次使用git branch查看，发现本地已经多出了一个新建的分支。   此时远程仓库并没有这个分支，我们需要使用git push origin 分支名 命令将本地修改推送到远程服务器上。   push完成后就可以在远程服务上看到新建的分支了（原本是1 branches）。  </description>
    </item>
    
    <item>
      <title>windows系统最简单的Hugo博客搭建</title>
      <link>https://longzhang0314.github.io/post/hugo%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 04 Sep 2019 10:11:02 +0800</pubDate>
      
      <guid>https://longzhang0314.github.io/post/hugo%E6%90%AD%E5%BB%BA/</guid>
      <description>1.安装
  需要提前安装git，并拥有一个github账号。 widows需要在https://github.com/gohugoio/hugo/releases处下载hugo运行需要的二级制码hugo_0.57.2_Windows-64bit.zip，并解压配置系统变量。
在命令行使用如下命令确认是否安装正确：
hugo version  打印如下内容表示安装成功：
Hugo Static Site Generator v0.57.2-A849CB2D windows/amd64 BuildDate: 2019-08-17T17:54:13Z   2. 生成站点 切换至想要创建的目录，运行：
hugo new site myblog  打印如下内容表示生成站点成功：
Congratulations! Your new Hugo site is created  3. 下载主题 cd myblog git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c  打印如下内容表示主题下载成功：
Cloning into &#39;themes/m10c&#39;... remote: Enumerating objects: 18, done. remote: Counting objects: 100% (18/18), done. remote: Compressing objects: 100% (17/17), done. remote: Total 265 (delta 4), reused 11 (delta 1), pack-reused 247 Receiving objects: 65% (173/265), 420.</description>
    </item>
    
  </channel>
</rss>